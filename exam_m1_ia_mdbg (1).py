# -*- coding: utf-8 -*-
"""Exam_M1_IA_MDBG.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1BqsIulFFaahgCM9bRtCemawZSP5AiP9j
"""

import matplotlib.pyplot as plt
import numpy as np

print('Exercice_1')
def tracer():
  x = np.linspace(0,1)
  f = pow(x,5)
  square_vertices = [(0, 0), (1, 0), (1, 1), (0, 1), (0, 0)]
  x_coords, y_coords = zip(*square_vertices)
  plt.title("Courbe d'equation x^5")
  plt.xlabel("x")
  plt.ylabel("f(x) = x^5")
  plt.plot(x_coords, y_coords)
  plt.plot(x,f)
  plt.grid()
  plt.show()
figure = tracer()



print('Exercice_2')
class Curve():
  def __init__(self,start,stop,nbr_points=5432):
    self.start = start
    self.stop = stop
    self.nbr_points = nbr_points

  def __fonction(self,x):
    y = pow(x,5)
    return y
  def point_position(self, x,y):
      if y > self.__fonction(x):
          return 'Above'
      elif y < self.__fonction(x):
          return 'Below'
      else:
          return 'On Curve'

  def draw_courbe(self, x_points=None):
    """ Méthode qui trace la courbe x5"""
    x_points = np.linspace(self.start,self.stop)
    y = [self.__fonction(i) for i in x_points]
    self.square_vertices = [(0, 0), (1, 0), (1, 1), (0, 1), (0, 0)]
    x_coords, y_coords = zip(*self.square_vertices)
    plt.title("Figure 1: Courbe d'équation x5 sur l'intervalle [0,1]")
    plt.plot(x_coords, y_coords)
    plt.plot(x_points,y, color = "red")
    plt.show()

  def generate_and_plot_points(self):
    x_vals = np.random.uniform(self.start, self.stop, self.nbr_points)
    y_vals_curve = y = np.random.uniform(0, 1.4, self.nbr_points)
    #rand_points =np.column_stack((x_vals, y_vals_curve))

        # Determine the position of each point relative to the curve
    return [x_vals,y_vals_curve]

  def draw (self):
    self.draw_courbe()
    x_vals = self.generate_and_plot_points()[0]
    y_vals = self.generate_and_plot_points()[1]
    #above = []
    #below = []
    points = self.generate_and_plot_points()
    positions= [self.point_position(x,y) for x,y in zip(x_vals,y_vals)] #in points]
    for i, position in enumerate(positions):
        if position == 'Above':
            x_above = x_vals[i]
            y_above = y_vals[i]
            plt.scatter(x_above,y_above,color = "blue", marker = "x")

        elif position == 'Below' :
            x_below = x_vals[i]
            y_below = y_vals[i]
           # below.append((x_below,y_below))
            plt.scatter(x_below, y_below, color = "green", marker = "o")
    plt.show()

curve_instance = Curve(start=-0, stop=1, nbr_points=100)
curve_instance.draw()